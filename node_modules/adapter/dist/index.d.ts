declare type InputTypes = {
    [type: string]: any;
};
declare type InputOptions<T extends InputTypes> = {
    [type in keyof T]?: {
        [option: string]: any;
    };
};
declare type InputKeys<T extends InputTypes> = {
    [key: string]: keyof T;
};
declare type InputFormat<T extends InputTypes = InputTypes> = {
    types: T;
    options?: InputOptions<T>;
    keys: InputKeys<T>;
};
declare type GetInputOptions<IF extends InputFormat, T extends keyof IF['types']> = 'options' extends keyof IF ? (T extends keyof IF['options'] ? IF['options'][T] : never) : never;
declare type InputReturn<IF extends InputFormat, K extends keyof IF['keys']> = IF['types'][IF['keys'][K]];
declare type InputBatchReturn<IF extends InputFormat, Ks extends keyof IF['keys']> = {
    [K in Ks]: InputReturn<IF, K>;
};
declare type Resolve<T> = (value?: T | PromiseLike<T>) => void;
declare type Reject = (reason?: any) => void;
declare type Output<T> = (data: T) => void;
declare type InputSingle<IF extends InputFormat> = <K extends keyof IF['keys'], T extends IF['keys'][K]>(key: K, type: T, options?: GetInputOptions<IF, T>) => Promise<InputReturn<IF, K>>;
declare type InputBatchValueDescriptor<IF extends InputFormat, K extends keyof IF['keys']> = IF['keys'][K] | {
    type: IF['keys'][K];
    options?: GetInputOptions<IF, IF['keys'][K]>;
};
declare type InputBatch<IF extends InputFormat> = <Ks extends keyof IF['keys'], Ts extends IF['keys'][Ks]>(values: {
    [K in Ks]: InputBatchValueDescriptor<IF, K>;
}, meta?: any) => Promise<InputBatchReturn<IF, Ks>>;
declare type HeadlessInput<IF extends InputFormat> = {
    [K in keyof IF['keys']]: InputReturn<IF, K>;
};
declare type Input<IF extends InputFormat> = InputSingle<IF> & {
    batch?: InputBatch<IF>;
};
declare type Attachments<R, I extends InputFormat, O> = {
    then?: Resolve<R>;
    catch?: Reject;
    output?: Output<O>;
    input?: InputSingle<I>;
    inputBatch?: InputBatch<I>;
};
/**
 * Defines the format of an AdapterExecutor.
 */
export declare type AdapterExecutor<R, I extends InputFormat, O> = (input?: Input<I>, output?: Output<O>) => Promise<R>;
/**
 * Contains metadata about the Adapter.
 */
export declare type AdapterMeta<R, I extends InputFormat, O> = {
    description?: string;
    inputs?: {
        [K in keyof I['keys']]: string;
    };
};
/**
 * Functionally similar to Promise<T>.
 * @see makeAdapter()
 */
export declare type Adapter<R, I extends InputFormat, O> = {
    exec: () => Promise<R>;
    promise: () => Promise<R>;
    output: (onOutput: Output<O>) => Adapter<R, I, O>;
    input: (onInput: InputSingle<I> | HeadlessInput<I>) => Adapter<R, I, O>;
    inputBatch: (onBatchInput: InputBatch<I>) => Adapter<R, I, O>;
    then: (resolve: Resolve<R>) => Adapter<R, I, O>;
    catch: (resolve: Reject) => Adapter<R, I, O>;
    attach: (attachments: Attachments<R, I, O>) => Adapter<R, I, O>;
    meta: AdapterMeta<R, I, O>;
};
/**
 * Takes an executor function and wraps it in an Adapter.
 */
export declare const makeAdapter: <R = any, I extends InputFormat<InputTypes> = InputFormat<InputTypes>, O = any>(executor: AdapterExecutor<R, I, O>, meta?: AdapterMeta<R, I, O>) => Adapter<R, I, O>;
export {};
